// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `runtime/runtime.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub source: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string source = 3;


    pub fn get_source(&self) -> &str {
        &self.source
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    // repeated .go.micro.runtime.Service.MetadataEntry metadata = 4;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Service| { &m.name },
                    |m: &mut Service| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Service| { &m.version },
                    |m: &mut Service| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &Service| { &m.source },
                    |m: &mut Service| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &Service| { &m.metadata },
                    |m: &mut Service| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                    "Service",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Service {
        static mut instance: ::protobuf::lazy::Lazy<Service> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Service::new)
        }
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.source.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub field_type: ::std::string::String,
    pub timestamp: i64,
    pub service: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // int64 timestamp = 2;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string service = 3;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string version = 4;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.service);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        if self.timestamp != 0 {
            os.write_int64(2, self.timestamp)?;
        }
        if !self.service.is_empty() {
            os.write_string(3, &self.service)?;
        }
        if !self.version.is_empty() {
            os.write_string(4, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Event| { &m.field_type },
                    |m: &mut Event| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &Event| { &m.timestamp },
                    |m: &mut Event| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &Event| { &m.service },
                    |m: &mut Event| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Event| { &m.version },
                    |m: &mut Event| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                    "Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Event::new)
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.field_type.clear();
        self.timestamp = 0;
        self.service.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOptions {
    // message fields
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    pub env: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::std::string::String,
    pub field_type: ::std::string::String,
    pub image: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOptions {
    fn default() -> &'a CreateOptions {
        <CreateOptions as ::protobuf::Message>::default_instance()
    }
}

impl CreateOptions {
    pub fn new() -> CreateOptions {
        ::std::default::Default::default()
    }

    // repeated string command = 1;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 2;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // repeated string env = 3;


    pub fn get_env(&self) -> &[::std::string::String] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // string output = 4;


    pub fn get_output(&self) -> &str {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }

    // string type = 5;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string image = 6;


    pub fn get_image(&self) -> &str {
        &self.image
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        &mut self.image
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image, ::std::string::String::new())
    }

    // string namespace = 7;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.env)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.env {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.output);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.field_type);
        }
        if !self.image.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.image);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        for v in &self.args {
            os.write_string(2, &v)?;
        };
        for v in &self.env {
            os.write_string(3, &v)?;
        };
        if !self.output.is_empty() {
            os.write_string(4, &self.output)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(5, &self.field_type)?;
        }
        if !self.image.is_empty() {
            os.write_string(6, &self.image)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(7, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOptions {
        CreateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    |m: &CreateOptions| { &m.command },
                    |m: &mut CreateOptions| { &mut m.command },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    |m: &CreateOptions| { &m.args },
                    |m: &mut CreateOptions| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "env",
                    |m: &CreateOptions| { &m.env },
                    |m: &mut CreateOptions| { &mut m.env },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output",
                    |m: &CreateOptions| { &m.output },
                    |m: &mut CreateOptions| { &mut m.output },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &CreateOptions| { &m.field_type },
                    |m: &mut CreateOptions| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    |m: &CreateOptions| { &m.image },
                    |m: &mut CreateOptions| { &mut m.image },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &CreateOptions| { &m.namespace },
                    |m: &mut CreateOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOptions>(
                    "CreateOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateOptions {
        static mut instance: ::protobuf::lazy::Lazy<CreateOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateOptions::new)
        }
    }
}

impl ::protobuf::Clear for CreateOptions {
    fn clear(&mut self) {
        self.command.clear();
        self.args.clear();
        self.env.clear();
        self.output.clear();
        self.field_type.clear();
        self.image.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<CreateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequest {
    fn default() -> &'a CreateRequest {
        <CreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequest {
    pub fn new() -> CreateRequest {
        ::std::default::Default::default()
    }

    // .go.micro.runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| Service::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .go.micro.runtime.CreateOptions options = 2;


    pub fn get_options(&self) -> &CreateOptions {
        self.options.as_ref().unwrap_or_else(|| CreateOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: CreateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut CreateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> CreateOptions {
        self.options.take().unwrap_or_else(|| CreateOptions::new())
    }
}

impl ::protobuf::Message for CreateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequest {
        CreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "service",
                    |m: &CreateRequest| { &m.service },
                    |m: &mut CreateRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CreateOptions>>(
                    "options",
                    |m: &CreateRequest| { &m.options },
                    |m: &mut CreateRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateRequest>(
                    "CreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponse {
    fn default() -> &'a CreateResponse {
        <CreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponse {
    pub fn new() -> CreateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponse {
        CreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateResponse>(
                    "CreateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CreateResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOptions {
    // message fields
    pub service: ::std::string::String,
    pub version: ::std::string::String,
    pub field_type: ::std::string::String,
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadOptions {
    fn default() -> &'a ReadOptions {
        <ReadOptions as ::protobuf::Message>::default_instance()
    }
}

impl ReadOptions {
    pub fn new() -> ReadOptions {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // string namespace = 4;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReadOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(4, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOptions {
        ReadOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &ReadOptions| { &m.service },
                    |m: &mut ReadOptions| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &ReadOptions| { &m.version },
                    |m: &mut ReadOptions| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &ReadOptions| { &m.field_type },
                    |m: &mut ReadOptions| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &ReadOptions| { &m.namespace },
                    |m: &mut ReadOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadOptions>(
                    "ReadOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadOptions {
        static mut instance: ::protobuf::lazy::Lazy<ReadOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReadOptions::new)
        }
    }
}

impl ::protobuf::Clear for ReadOptions {
    fn clear(&mut self) {
        self.service.clear();
        self.version.clear();
        self.field_type.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ReadOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadRequest {
    fn default() -> &'a ReadRequest {
        <ReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadRequest {
    pub fn new() -> ReadRequest {
        ::std::default::Default::default()
    }

    // .go.micro.runtime.ReadOptions options = 1;


    pub fn get_options(&self) -> &ReadOptions {
        self.options.as_ref().unwrap_or_else(|| ReadOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ReadOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ReadOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ReadOptions {
        self.options.take().unwrap_or_else(|| ReadOptions::new())
    }
}

impl ::protobuf::Message for ReadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadRequest {
        ReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadOptions>>(
                    "options",
                    |m: &ReadRequest| { &m.options },
                    |m: &mut ReadRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadRequest>(
                    "ReadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadRequest {
        static mut instance: ::protobuf::lazy::Lazy<ReadRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReadRequest::new)
        }
    }
}

impl ::protobuf::Clear for ReadRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadResponse {
    fn default() -> &'a ReadResponse {
        <ReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadResponse {
    pub fn new() -> ReadResponse {
        ::std::default::Default::default()
    }

    // repeated .go.micro.runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadResponse {
        ReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "services",
                    |m: &ReadResponse| { &m.services },
                    |m: &mut ReadResponse| { &mut m.services },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReadResponse>(
                    "ReadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadResponse {
        static mut instance: ::protobuf::lazy::Lazy<ReadResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ReadResponse::new)
        }
    }
}

impl ::protobuf::Clear for ReadResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOptions {
    fn default() -> &'a DeleteOptions {
        <DeleteOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &DeleteOptions| { &m.namespace },
                    |m: &mut DeleteOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOptions>(
                    "DeleteOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteOptions {
        static mut instance: ::protobuf::lazy::Lazy<DeleteOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeleteOptions::new)
        }
    }
}

impl ::protobuf::Clear for DeleteOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<DeleteOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    // .go.micro.runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| Service::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .go.micro.runtime.DeleteOptions options = 2;


    pub fn get_options(&self) -> &DeleteOptions {
        self.options.as_ref().unwrap_or_else(|| DeleteOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: DeleteOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut DeleteOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> DeleteOptions {
        self.options.take().unwrap_or_else(|| DeleteOptions::new())
    }
}

impl ::protobuf::Message for DeleteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "service",
                    |m: &DeleteRequest| { &m.service },
                    |m: &mut DeleteRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeleteOptions>>(
                    "options",
                    |m: &DeleteRequest| { &m.options },
                    |m: &mut DeleteRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRequest>(
                    "DeleteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeleteRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteResponse {
    fn default() -> &'a DeleteResponse {
        <DeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponse {
    pub fn new() -> DeleteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteResponse {
        DeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteResponse>(
                    "DeleteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeleteResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOptions {
    fn default() -> &'a UpdateOptions {
        <UpdateOptions as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOptions {
    pub fn new() -> UpdateOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOptions {
        UpdateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &UpdateOptions| { &m.namespace },
                    |m: &mut UpdateOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOptions>(
                    "UpdateOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateOptions {
        static mut instance: ::protobuf::lazy::Lazy<UpdateOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateOptions::new)
        }
    }
}

impl ::protobuf::Clear for UpdateOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRequest {
    // message fields
    pub service: ::protobuf::SingularPtrField<Service>,
    pub options: ::protobuf::SingularPtrField<UpdateOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    // .go.micro.runtime.Service service = 1;


    pub fn get_service(&self) -> &Service {
        self.service.as_ref().unwrap_or_else(|| Service::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: Service) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut Service {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> Service {
        self.service.take().unwrap_or_else(|| Service::new())
    }

    // .go.micro.runtime.UpdateOptions options = 2;


    pub fn get_options(&self) -> &UpdateOptions {
        self.options.as_ref().unwrap_or_else(|| UpdateOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: UpdateOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut UpdateOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> UpdateOptions {
        self.options.take().unwrap_or_else(|| UpdateOptions::new())
    }
}

impl ::protobuf::Message for UpdateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "service",
                    |m: &UpdateRequest| { &m.service },
                    |m: &mut UpdateRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateOptions>>(
                    "options",
                    |m: &UpdateRequest| { &m.options },
                    |m: &mut UpdateRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRequest>(
                    "UpdateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateResponse {
    fn default() -> &'a UpdateResponse {
        <UpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateResponse {
    pub fn new() -> UpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateResponse {
        UpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateResponse>(
                    "UpdateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UpdateResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOptions {
    fn default() -> &'a ListOptions {
        <ListOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &ListOptions| { &m.namespace },
                    |m: &mut ListOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOptions>(
                    "ListOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListOptions {
        static mut instance: ::protobuf::lazy::Lazy<ListOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListOptions::new)
        }
    }
}

impl ::protobuf::Clear for ListOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<ListOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    // .go.micro.runtime.ListOptions options = 1;


    pub fn get_options(&self) -> &ListOptions {
        self.options.as_ref().unwrap_or_else(|| ListOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ListOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ListOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> ListOptions {
        self.options.take().unwrap_or_else(|| ListOptions::new())
    }
}

impl ::protobuf::Message for ListRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListOptions>>(
                    "options",
                    |m: &ListRequest| { &m.options },
                    |m: &mut ListRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListRequest>(
                    "ListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListResponse {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    // repeated .go.micro.runtime.Service services = 1;


    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "services",
                    |m: &ListResponse| { &m.services },
                    |m: &mut ListResponse| { &mut m.services },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListResponse>(
                    "ListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ListResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListResponse {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsOptions {
    // message fields
    pub namespace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsOptions {
    fn default() -> &'a LogsOptions {
        <LogsOptions as ::protobuf::Message>::default_instance()
    }
}

impl LogsOptions {
    pub fn new() -> LogsOptions {
        ::std::default::Default::default()
    }

    // string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        &self.namespace
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        &mut self.namespace
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogsOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsOptions {
        LogsOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &LogsOptions| { &m.namespace },
                    |m: &mut LogsOptions| { &mut m.namespace },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsOptions>(
                    "LogsOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogsOptions {
        static mut instance: ::protobuf::lazy::Lazy<LogsOptions> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LogsOptions::new)
        }
    }
}

impl ::protobuf::Clear for LogsOptions {
    fn clear(&mut self) {
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogsRequest {
    // message fields
    pub service: ::std::string::String,
    pub stream: bool,
    pub count: i64,
    pub since: i64,
    pub options: ::protobuf::SingularPtrField<LogsOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogsRequest {
    fn default() -> &'a LogsRequest {
        <LogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogsRequest {
    pub fn new() -> LogsRequest {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // bool stream = 2;


    pub fn get_stream(&self) -> bool {
        self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream = false;
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: bool) {
        self.stream = v;
    }

    // int64 count = 3;


    pub fn get_count(&self) -> i64 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = v;
    }

    // int64 since = 4;


    pub fn get_since(&self) -> i64 {
        self.since
    }
    pub fn clear_since(&mut self) {
        self.since = 0;
    }

    // Param is passed by value, moved
    pub fn set_since(&mut self, v: i64) {
        self.since = v;
    }

    // .go.micro.runtime.LogsOptions options = 5;


    pub fn get_options(&self) -> &LogsOptions {
        self.options.as_ref().unwrap_or_else(|| LogsOptions::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: LogsOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut LogsOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> LogsOptions {
        self.options.take().unwrap_or_else(|| LogsOptions::new())
    }
}

impl ::protobuf::Message for LogsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.since = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if self.stream != false {
            my_size += 2;
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.since != 0 {
            my_size += ::protobuf::rt::value_size(4, self.since, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        if self.count != 0 {
            os.write_int64(3, self.count)?;
        }
        if self.since != 0 {
            os.write_int64(4, self.since)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogsRequest {
        LogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &LogsRequest| { &m.service },
                    |m: &mut LogsRequest| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stream",
                    |m: &LogsRequest| { &m.stream },
                    |m: &mut LogsRequest| { &mut m.stream },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "count",
                    |m: &LogsRequest| { &m.count },
                    |m: &mut LogsRequest| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "since",
                    |m: &LogsRequest| { &m.since },
                    |m: &mut LogsRequest| { &mut m.since },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogsOptions>>(
                    "options",
                    |m: &LogsRequest| { &m.options },
                    |m: &mut LogsRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogsRequest>(
                    "LogsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogsRequest {
        static mut instance: ::protobuf::lazy::Lazy<LogsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LogsRequest::new)
        }
    }
}

impl ::protobuf::Clear for LogsRequest {
    fn clear(&mut self) {
        self.service.clear();
        self.stream = false;
        self.count = 0;
        self.since = 0;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogRecord {
    // message fields
    pub timestamp: i64,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogRecord {
    fn default() -> &'a LogRecord {
        <LogRecord as ::protobuf::Message>::default_instance()
    }
}

impl LogRecord {
    pub fn new() -> LogRecord {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .go.micro.runtime.LogRecord.MetadataEntry metadata = 2;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LogRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata);
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.metadata, os)?;
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogRecord {
        LogRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &LogRecord| { &m.timestamp },
                    |m: &mut LogRecord| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &LogRecord| { &m.metadata },
                    |m: &mut LogRecord| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &LogRecord| { &m.message },
                    |m: &mut LogRecord| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogRecord>(
                    "LogRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogRecord {
        static mut instance: ::protobuf::lazy::Lazy<LogRecord> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LogRecord::new)
        }
    }
}

impl ::protobuf::Clear for LogRecord {
    fn clear(&mut self) {
        self.timestamp = 0;
        self.metadata.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15runtime/runtime.proto\x12\x10go.micro.runtime\"\xd1\x01\n\x07Servi\
    ce\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07version\
    \x18\x02\x20\x01(\tR\x07version\x12\x16\n\x06source\x18\x03\x20\x01(\tR\
    \x06source\x12C\n\x08metadata\x18\x04\x20\x03(\x0b2'.go.micro.runtime.Se\
    rvice.MetadataEntryR\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"m\n\x05Event\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04typ\
    e\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\x12\x18\n\x07ser\
    vice\x18\x03\x20\x01(\tR\x07service\x12\x18\n\x07version\x18\x04\x20\x01\
    (\tR\x07version\"\xaf\x01\n\rCreateOptions\x12\x18\n\x07command\x18\x01\
    \x20\x03(\tR\x07command\x12\x12\n\x04args\x18\x02\x20\x03(\tR\x04args\
    \x12\x10\n\x03env\x18\x03\x20\x03(\tR\x03env\x12\x16\n\x06output\x18\x04\
    \x20\x01(\tR\x06output\x12\x12\n\x04type\x18\x05\x20\x01(\tR\x04type\x12\
    \x14\n\x05image\x18\x06\x20\x01(\tR\x05image\x12\x1c\n\tnamespace\x18\
    \x07\x20\x01(\tR\tnamespace\"\x7f\n\rCreateRequest\x123\n\x07service\x18\
    \x01\x20\x01(\x0b2\x19.go.micro.runtime.ServiceR\x07service\x129\n\x07op\
    tions\x18\x02\x20\x01(\x0b2\x1f.go.micro.runtime.CreateOptionsR\x07optio\
    ns\"\x10\n\x0eCreateResponse\"s\n\x0bReadOptions\x12\x18\n\x07service\
    \x18\x01\x20\x01(\tR\x07service\x12\x18\n\x07version\x18\x02\x20\x01(\tR\
    \x07version\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x1c\n\tnam\
    espace\x18\x04\x20\x01(\tR\tnamespace\"F\n\x0bReadRequest\x127\n\x07opti\
    ons\x18\x01\x20\x01(\x0b2\x1d.go.micro.runtime.ReadOptionsR\x07options\"\
    E\n\x0cReadResponse\x125\n\x08services\x18\x01\x20\x03(\x0b2\x19.go.micr\
    o.runtime.ServiceR\x08services\"-\n\rDeleteOptions\x12\x1c\n\tnamespace\
    \x18\x01\x20\x01(\tR\tnamespace\"\x7f\n\rDeleteRequest\x123\n\x07service\
    \x18\x01\x20\x01(\x0b2\x19.go.micro.runtime.ServiceR\x07service\x129\n\
    \x07options\x18\x02\x20\x01(\x0b2\x1f.go.micro.runtime.DeleteOptionsR\
    \x07options\"\x10\n\x0eDeleteResponse\"-\n\rUpdateOptions\x12\x1c\n\tnam\
    espace\x18\x01\x20\x01(\tR\tnamespace\"\x7f\n\rUpdateRequest\x123\n\x07s\
    ervice\x18\x01\x20\x01(\x0b2\x19.go.micro.runtime.ServiceR\x07service\
    \x129\n\x07options\x18\x02\x20\x01(\x0b2\x1f.go.micro.runtime.UpdateOpti\
    onsR\x07options\"\x10\n\x0eUpdateResponse\"+\n\x0bListOptions\x12\x1c\n\
    \tnamespace\x18\x01\x20\x01(\tR\tnamespace\"F\n\x0bListRequest\x127\n\
    \x07options\x18\x01\x20\x01(\x0b2\x1d.go.micro.runtime.ListOptionsR\x07o\
    ptions\"E\n\x0cListResponse\x125\n\x08services\x18\x01\x20\x03(\x0b2\x19\
    .go.micro.runtime.ServiceR\x08services\"+\n\x0bLogsOptions\x12\x1c\n\tna\
    mespace\x18\x01\x20\x01(\tR\tnamespace\"\xa4\x01\n\x0bLogsRequest\x12\
    \x18\n\x07service\x18\x01\x20\x01(\tR\x07service\x12\x16\n\x06stream\x18\
    \x02\x20\x01(\x08R\x06stream\x12\x14\n\x05count\x18\x03\x20\x01(\x03R\
    \x05count\x12\x14\n\x05since\x18\x04\x20\x01(\x03R\x05since\x127\n\x07op\
    tions\x18\x05\x20\x01(\x0b2\x1d.go.micro.runtime.LogsOptionsR\x07options\
    \"\xc7\x01\n\tLogRecord\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttime\
    stamp\x12E\n\x08metadata\x18\x02\x20\x03(\x0b2).go.micro.runtime.LogReco\
    rd.MetadataEntryR\x08metadata\x12\x18\n\x07message\x18\x03\x20\x01(\tR\
    \x07message\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x012\x87\
    \x03\n\x07Runtime\x12M\n\x06Create\x12\x1f.go.micro.runtime.CreateReques\
    t\x1a\x20.go.micro.runtime.CreateResponse\"\0\x12G\n\x04Read\x12\x1d.go.\
    micro.runtime.ReadRequest\x1a\x1e.go.micro.runtime.ReadResponse\"\0\x12M\
    \n\x06Delete\x12\x1f.go.micro.runtime.DeleteRequest\x1a\x20.go.micro.run\
    time.DeleteResponse\"\0\x12M\n\x06Update\x12\x1f.go.micro.runtime.Update\
    Request\x1a\x20.go.micro.runtime.UpdateResponse\"\0\x12F\n\x04Logs\x12\
    \x1d.go.micro.runtime.LogsRequest\x1a\x1b.go.micro.runtime.LogRecord\"\0\
    0\x01J\xb1\"\n\x07\x12\x05\0\0\x89\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x02\x08\x18\n\n\n\x02\x06\0\x12\x04\x04\0\n\
    \x01\n\n\n\x03\x06\0\x01\x12\x03\x04\x08\x0f\n\x0b\n\x04\x06\0\x02\0\x12\
    \x03\x05\x08=\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x05\x0c\x12\n\x0c\n\
    \x05\x06\0\x02\0\x02\x12\x03\x05\x13\x20\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03\x05+9\n\x0b\n\x04\x06\0\x02\x01\x12\x03\x06\x087\n\x0c\n\x05\x06\0\
    \x02\x01\x01\x12\x03\x06\x0c\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\
    \x06\x11\x1c\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x06'3\n\x0b\n\x04\x06\
    \0\x02\x02\x12\x03\x07\x08=\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x07\
    \x0c\x12\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x07\x13\x20\n\x0c\n\x05\
    \x06\0\x02\x02\x03\x12\x03\x07+9\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x08\
    \x08=\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x08\x0c\x12\n\x0c\n\x05\x06\
    \0\x02\x03\x02\x12\x03\x08\x13\x20\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\
    \x08+9\n\x0b\n\x04\x06\0\x02\x04\x12\x03\t\x08;\n\x0c\n\x05\x06\0\x02\
    \x04\x01\x12\x03\t\x0c\x10\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\t\x11\
    \x1c\n\x0c\n\x05\x06\0\x02\x04\x06\x12\x03\t'-\n\x0c\n\x05\x06\0\x02\x04\
    \x03\x12\x03\t.7\n\n\n\x02\x04\0\x12\x04\x0c\0\x15\x01\n\n\n\x03\x04\0\
    \x01\x12\x03\x0c\x08\x0f\n\"\n\x04\x04\0\x02\0\x12\x03\x0e\x08\x18\x1a\
    \x15\x20name\x20of\x20the\x20service\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\
    \x0e\x08\x0c\x11\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x0e\x08\x0e\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x0e\x0f\x13\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x0e\x16\x17\n%\n\x04\x04\0\x02\x01\x12\x03\x10\x08\x1b\x1a\x18\x20v\
    ersion\x20of\x20the\x20service\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x10\
    \x08\x0e\x18\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x10\x08\x0e\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x10\x0f\x16\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x10\x19\x1a\n$\n\x04\x04\0\x02\x02\x12\x03\x12\x08\x1a\x1a\x17\
    \x20git\x20url\x20of\x20the\x20source\n\n\r\n\x05\x04\0\x02\x02\x04\x12\
    \x04\x12\x08\x10\x1b\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x12\x08\x0e\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x12\x0f\x15\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x12\x18\x19\n\x1f\n\x04\x04\0\x02\x03\x12\x03\x14\x08(\
    \x1a\x12\x20service\x20metadata\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\
    \x14\x08\x12\x1a\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x14\x08\x1a\n\x0c\
    \n\x05\x04\0\x02\x03\x01\x12\x03\x14\x1b#\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x03\x14&'\n\n\n\x02\x04\x01\x12\x04\x17\0\x1c\x01\n\n\n\x03\x04\x01\
    \x01\x12\x03\x17\x08\r\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x18\x08\x18\n\r\
    \n\x05\x04\x01\x02\0\x04\x12\x04\x18\x08\x17\x0f\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x03\x18\x08\x0e\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x18\x0f\
    \x13\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x18\x16\x17\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03\x19\x08\x1c\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\
    \x19\x08\x18\x18\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x19\x08\r\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03\x19\x0e\x17\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03\x19\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x1a\x08\
    \x1b\n\r\n\x05\x04\x01\x02\x02\x04\x12\x04\x1a\x08\x19\x1c\n\x0c\n\x05\
    \x04\x01\x02\x02\x05\x12\x03\x1a\x08\x0e\n\x0c\n\x05\x04\x01\x02\x02\x01\
    \x12\x03\x1a\x0f\x16\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1a\x19\x1a\
    \n\x0b\n\x04\x04\x01\x02\x03\x12\x03\x1b\x08\x1b\n\r\n\x05\x04\x01\x02\
    \x03\x04\x12\x04\x1b\x08\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\
    \x1b\x08\x0e\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03\x1b\x0f\x16\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03\x1b\x19\x1a\n\n\n\x02\x04\x02\x12\x04\
    \x1e\0-\x01\n\n\n\x03\x04\x02\x01\x12\x03\x1e\x08\x15\n!\n\x04\x04\x02\
    \x02\0\x12\x03\x20\x08$\x1a\x14\x20command\x20to\x20pass\x20in\n\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03\x20\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x20\x18\x1f\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x20\"#\n(\n\x04\x04\x02\x02\x01\x12\
    \x03\"\x08!\x1a\x1b\x20args\x20to\x20pass\x20into\x20command\n\n\x0c\n\
    \x05\x04\x02\x02\x01\x04\x12\x03\"\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\
    \x05\x12\x03\"\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\"\x18\x1c\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\"\x1f\x20\n%\n\x04\x04\x02\x02\
    \x02\x12\x03$\x08\x20\x1a\x18\x20environment\x20to\x20pass\x20in\n\n\x0c\
    \n\x05\x04\x02\x02\x02\x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\
    \x05\x12\x03$\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03$\x18\x1b\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03$\x1e\x1f\n\x20\n\x04\x04\x02\x02\
    \x03\x12\x03&\x08\x1a\x1a\x13\x20output\x20to\x20send\x20to\n\n\r\n\x05\
    \x04\x02\x02\x03\x04\x12\x04&\x08$\x20\n\x0c\n\x05\x04\x02\x02\x03\x05\
    \x12\x03&\x08\x0e\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03&\x0f\x15\n\x0c\
    \n\x05\x04\x02\x02\x03\x03\x12\x03&\x18\x19\n%\n\x04\x04\x02\x02\x04\x12\
    \x03(\x08\x18\x1a\x18\x20create\x20type\x20of\x20service\n\n\r\n\x05\x04\
    \x02\x02\x04\x04\x12\x04(\x08&\x1a\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\
    \x03(\x08\x0e\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03(\x0f\x13\n\x0c\n\
    \x05\x04\x02\x02\x04\x03\x12\x03(\x16\x17\n\x1b\n\x04\x04\x02\x02\x05\
    \x12\x03*\x08\x19\x1a\x0e\x20image\x20to\x20use\n\n\r\n\x05\x04\x02\x02\
    \x05\x04\x12\x04*\x08(\x18\n\x0c\n\x05\x04\x02\x02\x05\x05\x12\x03*\x08\
    \x0e\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03*\x0f\x14\n\x0c\n\x05\x04\
    \x02\x02\x05\x03\x12\x03*\x17\x18\n\x1f\n\x04\x04\x02\x02\x06\x12\x03,\
    \x08\x1d\x1a\x12\x20namespace\x20to\x20use\n\n\r\n\x05\x04\x02\x02\x06\
    \x04\x12\x04,\x08*\x19\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03,\x08\x0e\
    \n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03,\x0f\x18\n\x0c\n\x05\x04\x02\
    \x02\x06\x03\x12\x03,\x1b\x1c\n\n\n\x02\x04\x03\x12\x04/\02\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03/\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x030\x08\
    \x1c\n\r\n\x05\x04\x03\x02\0\x04\x12\x040\x08/\x17\n\x0c\n\x05\x04\x03\
    \x02\0\x06\x12\x030\x08\x0f\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x030\x10\
    \x17\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x030\x1a\x1b\n\x0b\n\x04\x04\x03\
    \x02\x01\x12\x031\x08\"\n\r\n\x05\x04\x03\x02\x01\x04\x12\x041\x080\x1c\
    \n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x031\x08\x15\n\x0c\n\x05\x04\x03\
    \x02\x01\x01\x12\x031\x16\x1d\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x031\
    \x20!\n\t\n\x02\x04\x04\x12\x034\0\x19\n\n\n\x03\x04\x04\x01\x12\x034\
    \x08\x16\n\n\n\x02\x04\x05\x12\x046\0?\x01\n\n\n\x03\x04\x05\x01\x12\x03\
    6\x08\x13\n\x1b\n\x04\x04\x05\x02\0\x12\x038\x08\x1b\x1a\x0e\x20service\
    \x20name\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x048\x086\x15\n\x0c\n\x05\x04\
    \x05\x02\0\x05\x12\x038\x08\x0e\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x038\
    \x0f\x16\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x038\x19\x1a\n%\n\x04\x04\x05\
    \x02\x01\x12\x03:\x08\x1b\x1a\x18\x20version\x20of\x20the\x20service\n\n\
    \r\n\x05\x04\x05\x02\x01\x04\x12\x04:\x088\x1b\n\x0c\n\x05\x04\x05\x02\
    \x01\x05\x12\x03:\x08\x0e\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03:\x0f\
    \x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03:\x19\x1a\n\x1e\n\x04\x04\
    \x05\x02\x02\x12\x03<\x08\x18\x1a\x11\x20type\x20of\x20service\n\n\r\n\
    \x05\x04\x05\x02\x02\x04\x12\x04<\x08:\x1b\n\x0c\n\x05\x04\x05\x02\x02\
    \x05\x12\x03<\x08\x0e\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03<\x0f\x13\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03<\x16\x17\n#\n\x04\x04\x05\x02\x03\
    \x12\x03>\x08\x1d\x1a\x16\x20namespace\x20of\x20service\n\n\r\n\x05\x04\
    \x05\x02\x03\x04\x12\x04>\x08<\x18\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\
    \x03>\x08\x0e\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03>\x0f\x18\n\x0c\n\
    \x05\x04\x05\x02\x03\x03\x12\x03>\x1b\x1c\n\n\n\x02\x04\x06\x12\x04A\0C\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03A\x08\x13\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03B\x08\x20\n\r\n\x05\x04\x06\x02\0\x04\x12\x04B\x08A\x15\n\x0c\n\
    \x05\x04\x06\x02\0\x06\x12\x03B\x08\x13\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03B\x14\x1b\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03B\x1e\x1f\n\n\n\
    \x02\x04\x07\x12\x04E\0G\x01\n\n\n\x03\x04\x07\x01\x12\x03E\x08\x14\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03F\x08&\n\x0c\n\x05\x04\x07\x02\0\x04\x12\
    \x03F\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03F\x11\x18\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03F\x19!\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03F$\
    %\n\n\n\x02\x04\x08\x12\x04I\0L\x01\n\n\n\x03\x04\x08\x01\x12\x03I\x08\
    \x15\n'\n\x04\x04\x08\x02\0\x12\x03K\x08\x1d\x1a\x1a\x20namespace\x20of\
    \x20the\x20service\n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04K\x08I\x17\n\x0c\
    \n\x05\x04\x08\x02\0\x05\x12\x03K\x08\x0e\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03K\x0f\x18\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03K\x1b\x1c\n\n\n\
    \x02\x04\t\x12\x04N\0Q\x01\n\n\n\x03\x04\t\x01\x12\x03N\x08\x15\n\x0b\n\
    \x04\x04\t\x02\0\x12\x03O\x08\x1c\n\r\n\x05\x04\t\x02\0\x04\x12\x04O\x08\
    N\x17\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03O\x08\x0f\n\x0c\n\x05\x04\t\x02\
    \0\x01\x12\x03O\x10\x17\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03O\x1a\x1b\n\
    \x0b\n\x04\x04\t\x02\x01\x12\x03P\x08\"\n\r\n\x05\x04\t\x02\x01\x04\x12\
    \x04P\x08O\x1c\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03P\x08\x15\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03P\x16\x1d\n\x0c\n\x05\x04\t\x02\x01\x03\
    \x12\x03P\x20!\n\t\n\x02\x04\n\x12\x03S\0\x19\n\n\n\x03\x04\n\x01\x12\
    \x03S\x08\x16\n\n\n\x02\x04\x0b\x12\x04U\0X\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03U\x08\x15\n'\n\x04\x04\x0b\x02\0\x12\x03W\x08\x1d\x1a\x1a\x20nam\
    espace\x20of\x20the\x20service\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04W\
    \x08U\x17\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03W\x08\x0e\n\x0c\n\x05\x04\
    \x0b\x02\0\x01\x12\x03W\x0f\x18\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03W\
    \x1b\x1c\n\n\n\x02\x04\x0c\x12\x04Z\0]\x01\n\n\n\x03\x04\x0c\x01\x12\x03\
    Z\x08\x15\n\x0b\n\x04\x04\x0c\x02\0\x12\x03[\x08\x1c\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04[\x08Z\x17\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03[\x08\
    \x0f\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03[\x10\x17\n\x0c\n\x05\x04\x0c\
    \x02\0\x03\x12\x03[\x1a\x1b\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03\\\x08\"\
    \n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\\\x08[\x1c\n\x0c\n\x05\x04\x0c\
    \x02\x01\x06\x12\x03\\\x08\x15\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03\\\
    \x16\x1d\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03\\\x20!\n\t\n\x02\x04\r\
    \x12\x03_\0\x19\n\n\n\x03\x04\r\x01\x12\x03_\x08\x16\n\n\n\x02\x04\x0e\
    \x12\x04a\0d\x01\n\n\n\x03\x04\x0e\x01\x12\x03a\x08\x13\n%\n\x04\x04\x0e\
    \x02\0\x12\x03c\x08\x1d\x1a\x18\x20namespace\x20to\x20list\x20from\n\n\r\
    \n\x05\x04\x0e\x02\0\x04\x12\x04c\x08a\x15\n\x0c\n\x05\x04\x0e\x02\0\x05\
    \x12\x03c\x08\x0e\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03c\x0f\x18\n\x0c\n\
    \x05\x04\x0e\x02\0\x03\x12\x03c\x1b\x1c\n\n\n\x02\x04\x0f\x12\x04f\0h\
    \x01\n\n\n\x03\x04\x0f\x01\x12\x03f\x08\x13\n\x0b\n\x04\x04\x0f\x02\0\
    \x12\x03g\x08\x20\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04g\x08f\x15\n\x0c\n\
    \x05\x04\x0f\x02\0\x06\x12\x03g\x08\x13\n\x0c\n\x05\x04\x0f\x02\0\x01\
    \x12\x03g\x14\x1b\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03g\x1e\x1f\n\n\n\
    \x02\x04\x10\x12\x04j\0l\x01\n\n\n\x03\x04\x10\x01\x12\x03j\x08\x14\n\
    \x0b\n\x04\x04\x10\x02\0\x12\x03k\x08&\n\x0c\n\x05\x04\x10\x02\0\x04\x12\
    \x03k\x08\x10\n\x0c\n\x05\x04\x10\x02\0\x06\x12\x03k\x11\x18\n\x0c\n\x05\
    \x04\x10\x02\0\x01\x12\x03k\x19!\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03k$\
    %\n\n\n\x02\x04\x11\x12\x04n\0q\x01\n\n\n\x03\x04\x11\x01\x12\x03n\x08\
    \x13\n'\n\x04\x04\x11\x02\0\x12\x03p\x08\x1d\x1a\x1a\x20namespace\x20of\
    \x20the\x20service\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04p\x08n\x15\n\x0c\
    \n\x05\x04\x11\x02\0\x05\x12\x03p\x08\x0e\n\x0c\n\x05\x04\x11\x02\0\x01\
    \x12\x03p\x0f\x18\n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03p\x1b\x1c\n\x0b\n\
    \x02\x04\x12\x12\x05s\0\x80\x01\x01\n\n\n\x03\x04\x12\x01\x12\x03s\x08\
    \x13\n*\n\x04\x04\x12\x02\0\x12\x03u\x08\x1b\x1a\x1d\x20service\x20to\
    \x20request\x20logs\x20for\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04u\x08s\
    \x14\n\x0c\n\x05\x04\x12\x02\0\x05\x12\x03u\x08\x0e\n\x0c\n\x05\x04\x12\
    \x02\0\x01\x12\x03u\x0f\x16\n\x0c\n\x05\x04\x12\x02\0\x03\x12\x03u\x19\
    \x1a\n*\n\x04\x04\x12\x02\x01\x12\x03w\x08\x18\x1a\x1d\x20stream\x20reco\
    rds\x20continuously\n\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04w\x08u\x1b\n\
    \x0c\n\x05\x04\x12\x02\x01\x05\x12\x03w\x08\x0c\n\x0c\n\x05\x04\x12\x02\
    \x01\x01\x12\x03w\r\x13\n\x0c\n\x05\x04\x12\x02\x01\x03\x12\x03w\x16\x17\
    \n*\n\x04\x04\x12\x02\x02\x12\x03y\x08\x18\x1a\x1d\x20count\x20of\x20rec\
    ords\x20to\x20request\n\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04y\x08w\x18\
    \n\x0c\n\x05\x04\x12\x02\x02\x05\x12\x03y\x08\r\n\x0c\n\x05\x04\x12\x02\
    \x02\x01\x12\x03y\x0e\x13\n\x0c\n\x05\x04\x12\x02\x02\x03\x12\x03y\x16\
    \x17\nY\n\x04\x04\x12\x02\x03\x12\x03}\x08\x18\x1aL\x20relative\x20time\
    \x20in\x20seconds\n\x20before\x20the\x20current\x20time\n\x20from\x20whi\
    ch\x20to\x20show\x20logs\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04}\x08y\
    \x18\n\x0c\n\x05\x04\x12\x02\x03\x05\x12\x03}\x08\r\n\x0c\n\x05\x04\x12\
    \x02\x03\x01\x12\x03}\x0e\x13\n\x0c\n\x05\x04\x12\x02\x03\x03\x12\x03}\
    \x16\x17\n\x1d\n\x04\x04\x12\x02\x04\x12\x03\x7f\x08\x20\x1a\x10\x20opti\
    ons\x20to\x20use\n\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\x7f\x08}\x18\n\
    \x0c\n\x05\x04\x12\x02\x04\x06\x12\x03\x7f\x08\x13\n\x0c\n\x05\x04\x12\
    \x02\x04\x01\x12\x03\x7f\x14\x1b\n\x0c\n\x05\x04\x12\x02\x04\x03\x12\x03\
    \x7f\x1e\x1f\n\x0c\n\x02\x04\x13\x12\x06\x82\x01\0\x89\x01\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\x82\x01\x08\x11\n'\n\x04\x04\x13\x02\0\x12\x04\
    \x84\x01\x08\x1c\x1a\x19\x20timestamp\x20of\x20log\x20record\n\n\x0f\n\
    \x05\x04\x13\x02\0\x04\x12\x06\x84\x01\x08\x82\x01\x13\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\x84\x01\x08\r\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x84\
    \x01\x0e\x17\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x84\x01\x1a\x1b\n\x1f\n\
    \x04\x04\x13\x02\x01\x12\x04\x86\x01\x08(\x1a\x11\x20record\x20metadata\
    \n\n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\x86\x01\x08\x84\x01\x1c\n\r\n\
    \x05\x04\x13\x02\x01\x06\x12\x04\x86\x01\x08\x1a\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\x86\x01\x1b#\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x86\
    \x01&'\n\x17\n\x04\x04\x13\x02\x02\x12\x04\x88\x01\x08\x1b\x1a\t\x20mess\
    age\n\n\x0f\n\x05\x04\x13\x02\x02\x04\x12\x06\x88\x01\x08\x86\x01(\n\r\n\
    \x05\x04\x13\x02\x02\x05\x12\x04\x88\x01\x08\x0e\n\r\n\x05\x04\x13\x02\
    \x02\x01\x12\x04\x88\x01\x0f\x16\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\
    \x88\x01\x19\x1ab\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
